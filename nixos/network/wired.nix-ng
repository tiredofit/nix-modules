{ config, lib, pkgs, ... }:

with lib;

{
  options = {
    host.network.wired = mkOption {
      type = types.attrsOf (types.submodule {
        options = {
          type = mkOption {
            type = types.nullOr (types.enum [ "static" "dynamic" "unmanaged" ]);
            default = null;
            description = "Addressing type: 'static', 'dynamic', 'unmanaged' - means no addressing is configured.";
            example = "dynamic";
          };
          ip = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = "IP/4 address with subnet";
            example = "10.11.12.13/29";
          };
          gateway = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = "Gateway IP address";
            example = "10.11.12.9 what would be the gateway ip for ip 10.11.12.13/29";
          };
          dns = mkOption {
            type = types.nullOr (types.listOf types.str);
            default = null;
            description = "List of DNS server IP addresses";
            example = "[ "1.1.1.1" "1.0.0.1" ]";
          };
          mac = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = "MAC address of the wired interface";
            example = "00:01:02:ab:cd:ef";
          };
          matchName = mkOption {
            type = types.nullOr types.str;
            default = null;
            description = "Match interface by name";
            example = "enp3s0f0";
          };
          mtu = mkOption {
            type = types.nullOr types.int;
            default = null;
            description = "MTU size for the interface";
            example = 1500;
          };
        };
      });
      default = { };
      description = "Multiple named wired interface configurations";
    };
    host.network.wiredAutoEnableNetworkd = mkOption {
      type = types.bool;
      default = true;
      description = "Auto-enable systemd-networkd if wired entries exist and no explicit manager is set.";
    };
  };

  config = let
    wireds = config.host.network.wired;
    mkEntry = name: w: let
      _warn = if (w.type == "static") && (w.gateway == null)
        then builtins.trace ("[host.network.wired." + name + ".gateway] Static interface has no gateway; continuing without gateway") null
        else null;
    in {
      name = name;
      value = {
        matchConfig =
          (if w.mac != null then { MACAddress = w.mac; } else { })
          // (if w.matchName != null then { Name = w.matchName; } else { });
        networkConfig =
          (if w.type == "dynamic" then { DHCP = "yes"; } else { });
        address =
          mkIf (w.type == "static") (if w.ip != null then [ w.ip ] else [ ]);
        dns = if w.type == "static" && w.dns != null then w.dns else [ ];
        routes = mkIf (w.type == "static" && w.gateway != null) [{
          Gateway = w.gateway;
          GatewayOnLink = true;
        }];
        linkConfig = mkForce
          ((if w.mtu != null then { MTUBytes = toString w.mtu; } else { }) // {
            RequiredForOnline = mkIf ((w.type == "static") && (w.gateway != null)) "routable";
          });
      };
    };

  in let wiredCount = builtins.length (builtins.attrNames wireds);
  in let per = mapAttrsToList (name: w: mkEntry name w) wireds;
  in {
    networking.useNetworkd = mkDefault ( # Prefer an explicit manager choice; otherwise auto-enable only when option allows it and wired entries exist
      if config.host.network.manager != null then
        config.host.network.manager == "systemd-networkd"
      else
        (config.host.network.wiredAutoEnableNetworkd && wiredCount > 0)
    );
    systemd.network.networks = mkIf config.networking.useNetworkd (listToAttrs per);

    assertions = concatLists (map (name:
      let w = wireds.${name}; in [
        {
          assertion = (w.type == "static") -> (w.ip != null);
          message = "[host.network.wired." + name + ".ip] Static interface requires an IP address";
        }
        {
          assertion = (w.mac != null) || (w.matchName != null);
          message = "[host.network.wired." + name + "] Provide either 'mac' or 'matchName' to identify the interface";
        }
      ]) (builtins.attrNames wireds));
  };
}
